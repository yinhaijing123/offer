/*************************************************************************************************************************
问题描述：有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
		说明：
			整数除法只保留整数部分。
			给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况
		
		示例 1：
			输入：tokens = ["2","1","+","3","*"]
			输出：9
			解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

						

思路分析：
         （中缀表达式：2+3*10；  后缀表达式（逆波兰表达式）:3 10 * 2 +）
          1. 中缀表达式转换为后缀表达式：借助顺序表(存转换后的后缀表达式)+栈（存运算符+ - * /），转换过程中（）括号优先级最低。
		  遍历中缀表达式字符串：当遇到数值时，将其放入顺序表中，
		  当遇到运算符时，将该运算符与栈顶元素的优先级进行比较，
		  如果栈顶元素的优先局高于该运算符，则出栈栈顶元素（保证栈顶元素始终是优先级最高的运算符）同时将出栈的运算符插入顺序表中。
		  继续遍历中缀表达式。
		  2.通过后缀表达式进行计算：
		  利用栈（保存过程操作数及运算结果）。
		  遍历字符串，如果是运算符，则从栈顶取两个操作数，根据运算符进行运算并将运算结果压栈；
		  若该字符为数字字符，则将其转换为数字进行压栈。直到遍历完字符串栈顶元素即为最终结果。
**************************************************************************************************************************/

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for(auto& str:tokens)
        {
            if(str=="+" || str=="-" ||str=="*"||str=="/")  //遇到操作符则从栈顶取元素进行运算，并将结果进行压栈操作
            {
                //从栈顶去两个操作数
                int right=s.top();
                s.pop();
                int left=s.top();
                s.pop();

                //运算
                if(str=="+")
                    s.push(left+right);
                else if(str=="-")
                    s.push(left-right);
                else if(str=="*")
                    s.push(left*right);
                else
                    s.push(left/right);
            }
            else
            {
                s.push(stoi(str));           //操作数入栈
            }
        }
        return s.top();
    }
};
