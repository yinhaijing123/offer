/*************************************************************************************************************************
问题描述：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。找出这两个只出现一次的数字。
		  要求：时间复杂度是O(n)，空间复杂度是O(1)。

思路分析：法1：根据相同数字进行异或操作结果为0性质；
		  ①将数组所有元素进行异或操作，得到结果即为数组中不成双的两个数字的异或结果；
		  ②找出所得结果二进制为1的比特位flag。该位为1则表示不成双的两个数字的二进制位在该位不同，即一个为0，一个为1；
		  ③根据这个特点，将数组分为两组。其中一组flag位为1，另一组flag位为0。这样便会将不成双的两个数字分开。
		  ④将这两组数据分别进行异或操作，则得到要找的两个数。
**************************************************************************************************************************/

int* singleNumbers(int* nums, int numsSize, int* returnSize){
    int rel=0;
    for(int i=0;i<numsSize;++i)
    {
        rel^=nums[i];
    }
    int k=0;
    int flag=1;
    while(1)
    {
        if(flag & rel)
            break;
        flag<<=1;
    }

    //分组
    int *ret=(int *)malloc(sizeof(int)*2);
    ret[0]=0;
    ret[1]=0;
    *returnSize=2;
    for(int i=0;i<numsSize;++i)
    {
        if(nums[i] & flag)
        {
            ret[0]^=nums[i];
        }
        else
        {
            ret[1]^=nums[i];
        }
    }
    return ret;

}
